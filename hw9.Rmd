---
title: "Assignment 9"
author: "Guandi Xu"
date: "11/14/2020"
documentclass: article
papersize: letter
fontsize: 11pt
output: pdf_document
---

## Monte Carlo Integration

#### 7.5.1 Important Sampling

a. From the question we know that:
Estimator is $$\frac{1}{n}\sum{x^2*(f/g)}$$.
And the variance of estimator is $$\frac{1}{n^2}Var(\sum{x^2*(f/g)}) = \frac{1}{n}Var(x^2*(f/g))$$

Design a function to show the result.

```{r}
important <- function(n){
  x <- rnorm(n,mean = 0, sd=1)
  f <- 1/(5*sqrt(2*pi)) * x^2 *exp(((x-2)^2)/(-2))
  g <- dnorm(x)
  x^2 * (f/g)
}
result <- matrix(0,3,2)
n <- c(1000,10000,50000)
for (i in 1:3) {
  result[i,] <- c(mean(important(n[i])), 1/n[i] * var(important(n[i])))
}
colnames(result) <- c("Estimator","Variance of Estimator")
rownames(result) <- c("n=1000","n=10000","n=50000")
knitr::kable(result)
```

b & c. Let g(x) be normal distribution with mean 2 and sd 1.
Therefore, we can get $$\frac{f}{g}=\frac{1}{5}x^2$$

```{r}
important2 <- function(n){
  x <- rnorm(n,mean = 2, sd=1)
  f <- 1/(5*sqrt(2*pi)) * x^2 *exp(((x-2)^2)/(-2))
  g <- dnorm(x,mean = 2, sd=1)
  x^2 * (f/g)
}
result <- matrix(0,3,2)
n <- c(1000,10000,50000)
for (i in 1:3) {
  result[i,] <- c(mean(important2(n[i])), 1/n[i] * var(important2(n[i])))
}
colnames(result) <- c("Estimator","Variance of Estimator")
rownames(result) <- c("n=1000","n=10000","n=50000")
knitr::kable(result)
```

d. Comparing the result of the two tables, we can get that if (f/g) is simple enough, our estimation will become much more precisely and have lower volitality.


#### 7.5.2

a. Based on the Ito fomula, we can get the result that:
$$
S(t)=S(0) e^{(r-\frac{\sigma^2}{2})t+\sigma W(t)}
$$
so that, we can get
$$
S(t+\Delta) = S(t) e^{(r-\frac{\sigma^2}{2})\Delta+\sigma\sqrt\Delta Z}
$$
Since that Z is the standard normal distribution with mean 0 and variance 1, we can easily simulate this brownian motion by randamly generating N(0,1) numbers step by step.

```{r}
sim <- function(sigma,t){
  s <- rep(0,13)
  s[1] <- 1
  for (i in 2:13) {
    s[i] <- s[i-1]*exp((0.05-(sigma^2)/2)*(t/12)+sigma*sqrt(t/12)*rnorm(1))
  }
  return(s)
}
##For example
sim(0.5,1)
```

b. The correlation coefficients are going down when K is increasing.

```{r}
k <- c(1.1,1.2,1.3,1.4,1.5)
corraltion <- function(k,sigma,t){
  pa <- pe <- pg <- st <- rep(0,5000)
for (i in 1:5000){
  v <- sim(sigma,t)
  st[i] <- v[13]
  pa[i] <- exp(-0.05) * (mean(v[2:13]) - k) * (mean(v[2:13]) > k)
  pg[i] <- exp(-0.05) * (exp(mean(log(v[2:13]))) - k) * (exp(mean(log(v[2:13]))) > k)
  pe[i] <- exp(-0.05) * (v[13] - k) * (v[13] > k)
}
return(c(cor(st,pa),cor(pa,pe),cor(pa,pg)))
}
corr <- matrix(0,3,5)
for (i in 1:5) {
  corr[,i] <- corraltion(k[i],0.5,1)
}
colnames(corr) <- paste0("k=",k)
rownames(corr) <- c("corr(pa, st)", "corr(pa, pe)", "corr(pa, pg)")
knitr::kable(corr)
```

c. corr(pa, st) and corr(pa, pe) are going up when sigma is increasing. And for all of them, when sigma equals 0.5, correlation coefficients does not exit.

```{r}
sigma <- c(0.2,0.3,0.4,0.5)
hyc <- matrix(0,3,4)
for (i in 1:4){
  hyc[,i] <- corraltion(1.5,sigma[i],1)
}
colnames(hyc) <- paste0("sigma=",sigma)
rownames(hyc) <- c("corr(pa, st)", "corr(pa, pe)", "corr(pa, pg)")
knitr::kable(hyc)
```

d. The result shows that there is no obvious trend of correlation (neither increase nor decrease) coefficients for corr(pa, pg) when t is increasing. However, corr(pa, pe) and corr(pa, st) keep increasing.

```{r}
t <- c(0.4,0.7,1,1.3,1.6)
wct <- matrix(0,3,5)
for (i in 1:5){
  wct[,i] <- corraltion(1.5,0.5,t[i])
}
colnames(wct) <- paste0("t=",t)
rownames(wct) <- c("corr(pa, st)", "corr(pa, pe)", "corr(pa, pg)")
knitr::kable(wct)
```

e. Change the parameters value again to show the result.

```{r}
pa <- pg <- pa1 <- pg1 <- rep(0,5000)
for (i in 1:5000) {
  v <- sim(0.4,1)
  pa[i] <- exp(-0.05) * (mean(v[2:13]) - 1) * (mean(v[2:13]) > 1)
  pg[i] <- exp(-0.05) * (exp(mean(log(v[2:13]))) - 1) * (exp(mean(log(v[2:13]))) > 1)
}
for (j in 1:5000) {
  v <- sim(0.4,1)
  pa1[i] <- exp(-0.05) * (mean(v[2:13]) - 1) * (mean(v[2:13]) > 1)
  pg1[i] <- exp(-0.05) * (exp(mean(log(v[2:13]))) - 1) * (exp(mean(log(v[2:13]))) > 1)
}
zly <- matrix(0,2,2)
zly[1,] <- c(mean(pa - cov(pa1, pg1)/var(pg1) * (pg - mean(pg1))),
            sd(pa - cov(pa1, pg1)/var(pg1) * (pg - mean(pg1)))/sqrt(5000))
zly[2,] <- c(mean(pa), sd(pa)/sqrt(5000))
rownames(zly) <- c("MC Estimator", "Control Variate")
colnames(zly) <- c("Estimates", "Standard deviation")
knitr::kable(zly)
```

